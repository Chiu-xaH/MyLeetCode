//一个机器人位于一个 m x n 网格的左上角
//机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角
//问总共有多少条不同的路径？
/*例如：m=3,n=2
[1,1]
[1,X]
[1,X]
思路：
想办法记录dp数组，dp数组的值代表从起点到达当前点有几种方法
由于在起点正下方与正右方，都只有一种方法到达，所以初始化为1
然后未初始化的点想到达，可以从它的上方点或者左方点过来，那么到达这个点的方法就等于它左面与上面到达方法之和
递归公式已找到，用循环初始化，最后返回终点的值
*/
int uniquePaths(int m, int n) {
    int dp[m][n];
    for(int i = 0;i < m;i++) {
        dp[i][0] = 1;
    }
    for(int i = 0;i < n;i++) {
        dp[0][i] = 1;
    }
    for(int i = 1;i < m;i++) {
        for(int j = 1;j < n;j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
}

